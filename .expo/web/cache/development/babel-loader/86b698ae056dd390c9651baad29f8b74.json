{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.computeGeometry = function (contentSize, placement, fromRect, displayArea, arrowSize) {\n  var effectiveArrowSize = getArrowSize(arrowSize, placement);\n\n  switch (placement) {\n    case 'top':\n      return computeTopGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n\n    case 'bottom':\n      return computeBottomGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n\n    case 'left':\n      return computeLeftGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n\n    case 'right':\n      return computeRightGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n\n    default:\n      return computeAutoGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n  }\n};\n\nvar getArrowSize = function getArrowSize(size, placement) {\n  if (placement === 'left' || placement === 'right') {\n    return {\n      width: size.height,\n      height: size.width\n    };\n  }\n\n  return size;\n};\n\nvar computeTopGeometry = function computeTopGeometry(displayArea, fromRect, contentSize, arrowSize) {\n  var origin = {\n    x: Math.min(displayArea.x + displayArea.width - contentSize.width, Math.max(displayArea.x, fromRect.x + (fromRect.width - contentSize.width) / 2)),\n    y: fromRect.y - contentSize.height - arrowSize.height\n  };\n  var anchor = {\n    x: fromRect.x + fromRect.width / 2,\n    y: fromRect.y\n  };\n  return {\n    origin: origin,\n    anchor: anchor,\n    placement: 'top'\n  };\n};\n\nvar computeBottomGeometry = function computeBottomGeometry(displayArea, fromRect, contentSize, arrowSize) {\n  var origin = {\n    x: Math.min(displayArea.x + displayArea.width - contentSize.width, Math.max(displayArea.x, fromRect.x + (fromRect.width - contentSize.width) / 2)),\n    y: fromRect.y + fromRect.height + arrowSize.height\n  };\n  var anchor = {\n    x: fromRect.x + fromRect.width / 2,\n    y: fromRect.y + fromRect.height\n  };\n  return {\n    origin: origin,\n    anchor: anchor,\n    placement: 'bottom'\n  };\n};\n\nvar computeLeftGeometry = function computeLeftGeometry(displayArea, fromRect, contentSize, arrowSize) {\n  var origin = {\n    x: fromRect.x - contentSize.width - arrowSize.width,\n    y: Math.min(displayArea.y + displayArea.height - contentSize.height, Math.max(displayArea.y, fromRect.y + (fromRect.height - contentSize.height) / 2))\n  };\n  var anchor = {\n    x: fromRect.x,\n    y: fromRect.y + fromRect.height / 2\n  };\n  return {\n    origin: origin,\n    anchor: anchor,\n    placement: 'left'\n  };\n};\n\nvar computeRightGeometry = function computeRightGeometry(displayArea, fromRect, contentSize, arrowSize) {\n  var origin = {\n    x: fromRect.x + fromRect.width + arrowSize.width,\n    y: Math.min(displayArea.y + displayArea.height - contentSize.height, Math.max(displayArea.y, fromRect.y + (fromRect.height - contentSize.height) / 2))\n  };\n  var anchor = {\n    x: fromRect.x + fromRect.width,\n    y: fromRect.y + fromRect.height / 2\n  };\n  return {\n    origin: origin,\n    anchor: anchor,\n    placement: 'right'\n  };\n};\n\nvar computeAutoGeometry = function computeAutoGeometry(displayArea, fromRect, contentSize, arrowSize) {\n  var geom = null;\n  var placements = ['left', 'top', 'right', 'bottom'];\n\n  for (var i = 0; i < 4; i += 1) {\n    var placement = placements[i];\n    geom = exports.computeGeometry(contentSize, placement, fromRect, displayArea, arrowSize);\n    var origin = geom.origin;\n\n    if (origin.x >= displayArea.x && origin.x <= displayArea.x + displayArea.width - contentSize.width && origin.y >= displayArea.y && origin.y <= displayArea.y + displayArea.height - contentSize.height) {\n      break;\n    }\n  }\n\n  return geom;\n};","map":{"version":3,"sources":["../src/PopoverGeometry.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computeGeometry = function (contentSize, placement, fromRect, displayArea, arrowSize) {\n    var effectiveArrowSize = getArrowSize(arrowSize, placement);\n    switch (placement) {\n        case 'top':\n            return computeTopGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n        case 'bottom':\n            return computeBottomGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n        case 'left':\n            return computeLeftGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n        case 'right':\n            return computeRightGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n        default:\n            return computeAutoGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n    }\n};\nvar getArrowSize = function (size, placement) {\n    if (placement === 'left' || placement === 'right') {\n        return { width: size.height, height: size.width };\n    }\n    return size;\n};\nvar computeTopGeometry = function (displayArea, fromRect, contentSize, arrowSize) {\n    var origin = {\n        x: Math.min(displayArea.x + displayArea.width - contentSize.width, Math.max(displayArea.x, fromRect.x + (fromRect.width - contentSize.width) / 2)),\n        y: fromRect.y - contentSize.height - arrowSize.height,\n    };\n    var anchor = { x: fromRect.x + fromRect.width / 2, y: fromRect.y };\n    return { origin: origin, anchor: anchor, placement: 'top' };\n};\nvar computeBottomGeometry = function (displayArea, fromRect, contentSize, arrowSize) {\n    var origin = {\n        x: Math.min(displayArea.x + displayArea.width - contentSize.width, Math.max(displayArea.x, fromRect.x + (fromRect.width - contentSize.width) / 2)),\n        y: fromRect.y + fromRect.height + arrowSize.height,\n    };\n    var anchor = { x: fromRect.x + fromRect.width / 2, y: fromRect.y + fromRect.height };\n    return { origin: origin, anchor: anchor, placement: 'bottom' };\n};\nvar computeLeftGeometry = function (displayArea, fromRect, contentSize, arrowSize) {\n    var origin = {\n        x: fromRect.x - contentSize.width - arrowSize.width,\n        y: Math.min(displayArea.y + displayArea.height - contentSize.height, Math.max(displayArea.y, fromRect.y + (fromRect.height - contentSize.height) / 2)),\n    };\n    var anchor = { x: fromRect.x, y: fromRect.y + fromRect.height / 2 };\n    return { origin: origin, anchor: anchor, placement: 'left' };\n};\nvar computeRightGeometry = function (displayArea, fromRect, contentSize, arrowSize) {\n    var origin = {\n        x: fromRect.x + fromRect.width + arrowSize.width,\n        y: Math.min(displayArea.y + displayArea.height - contentSize.height, Math.max(displayArea.y, fromRect.y + (fromRect.height - contentSize.height) / 2)),\n    };\n    var anchor = { x: fromRect.x + fromRect.width, y: fromRect.y + fromRect.height / 2 };\n    return { origin: origin, anchor: anchor, placement: 'right' };\n};\nvar computeAutoGeometry = function (displayArea, fromRect, contentSize, arrowSize) {\n    var geom = null;\n    var placements = ['left', 'top', 'right', 'bottom'];\n    for (var i = 0; i < 4; i += 1) {\n        var placement = placements[i];\n        geom = exports.computeGeometry(contentSize, placement, fromRect, displayArea, arrowSize);\n        var origin = geom.origin;\n        if (origin.x >= displayArea.x &&\n            origin.x <= displayArea.x + displayArea.width - contentSize.width &&\n            origin.y >= displayArea.y &&\n            origin.y <= displayArea.y + displayArea.height - contentSize.height) {\n            break;\n        }\n    }\n    return geom;\n};\n//# sourceMappingURL=PopoverGeometry.js.map"]},"metadata":{},"sourceType":"script"}